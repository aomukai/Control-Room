{
  "version": 1,
  "prompts": [
    {
      "id": "search_issues",
      "name": "Search Issues",
      "archetype": "Any",
      "scope": "project",
      "usageNotes": "Find issues by shared tags, assignment, or personal tags for the active agent.",
      "goals": "Retrieve relevant issues quickly and avoid re-reading irrelevant threads.",
      "guardrails": "Do not invent issues. Use only the filters provided.",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"search_issues\",\"args\":{\"tags\":[\"tag\"],\"assignedTo\":\"agent\",\"status\":\"open\",\"priority\":\"normal\",\"personalTags\":[\"tag\"],\"personalAgent\":\"agentId\",\"excludePersonalTags\":[\"tag\"],\"minInterestLevel\":1},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- tags?: string[]\n- assignedTo?: string\n- status?: \"open\" | \"closed\" | \"all\"\n- priority?: \"low\" | \"normal\" | \"high\" | \"urgent\"\n- personalTags?: string[]\n- personalAgent?: string\n- excludePersonalTags?: string[]\n- minInterestLevel?: number\n\nNotes:\n- personalTags filters on the agent's personal tags; requires personalAgent (agentId).\n- excludePersonalTags can hide items marked irrelevant."
    },
    {
      "id": "file_locator",
      "name": "File Locator",
      "archetype": "Any",
      "scope": "project",
      "usageNotes": "Use to find relevant files before analysis. Required first step for scenes, canon, or outline tasks.",
      "goals": "Locate real project files, report metadata with confidence/match basis, and avoid assuming file contents.",
      "guardrails": "Return actual file paths only. Never invent files. Include confidence and match_basis for each metadata field. If DEEP_SCAN exceeds safe context, warn and request confirmation.",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"file_locator\",\"args\":{\"search_criteria\":\"Story/SCN-outline.md\",\"scan_mode\":\"FAST_SCAN\",\"max_results\":12,\"include_globs\":false,\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- search_criteria: string (required)\n- scan_mode?: \"FAST_SCAN\" | \"DEEP_SCAN\"\n- max_results?: number\n- include_globs?: boolean\n- dry_run?: boolean\n\nSearch locations:\n- Story/Scenes/ (scene files, e.g. Story/Scenes/SCN-scene-slug.md)\n- Compendium/ (canon/worldbuilding, e.g. Compendium/Characters/CHAR-name.md)\n- Story/SCN-outline.md (story structure, virtual)\n\nMetadata fields to return per file:\n- Type: scene/canon/outline\n- POV (if scene) with confidence and match_basis\n- Scene # (if applicable) with confidence and match_basis\n- Size: word count or file size\n- Modified: last modified timestamp\n- Keywords: list with confidence and match_basis\n\nMatch basis values: FILENAME_MATCH | CONTENT_MATCH | METADATA_MATCH\n\nIf scan_mode=DEEP_SCAN, estimate token usage before loading content:\nDEEP_SCAN requested on [N] files (estimated [TOKENS] tokens).\nWARNING if TOKENS > 30000. Recommend FAST_SCAN or reduce scope to <= 6 files.\nProceed anyway? [yes/no]\n\nIf dry_run=true, output what would be scanned and estimated token usage only."
    },
    {
      "id": "file_reader",
      "name": "File Reader",
      "archetype": "Any",
      "scope": "project",
      "usageNotes": "Use to read a specific line range from a file so quotes and line references can be grounded deterministically.",
      "goals": "Return a line-numbered excerpt from a VFS file for evidence and editing tools.",
      "guardrails": "Never invent file contents. Require an existing VFS file path (use file_locator first if needed). Keep excerpts small (<= 250 lines).",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"file_reader\",\"args\":{\"file_path\":\"Story/SCN-outline.md\",\"start_line\":1,\"end_line\":40,\"include_line_numbers\":true,\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- file_path: string (required)\n- start_line?: number (default: 1)\n- end_line?: number (default: start_line + ~80; capped)\n- include_line_numbers?: boolean (default: true)\n- dry_run?: boolean\n\nTip: If the model tries `read_file`, the backend will alias it to `file_reader`."
    },
    {
      "id": "task_router",
      "name": "Task Router",
      "archetype": "Chief",
      "scope": "project",
      "usageNotes": "Use when a user request needs routing to specialized agents or tools.",
      "goals": "Classify task type, choose role(s), define evidence type, and specify required context.",
      "guardrails": "Do not hardcode agent names. Route by role. If a role is unavailable, route to Chief with FALLBACK reason. If ambiguous, output CLARIFY questions before routing.",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"task_router\",\"args\":{\"user_request\":\"...\",\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- user_request: string (required)\n- dry_run?: boolean\n\nAvailable roles:\n- planner (outline structure, scene ordering, stakes)\n- writer (prose drafting, scenes, dialogue)\n- editor (line editing, clarity, consistency)\n- critic (narrative impact, reader experience)\n- continuity (timeline, canon consistency, character tracking)\n- chief (router/moderator)\n\nOutput format (exact fields):\nROUTE: [role or roles]\nORDER: [sequential order if multiple]\nPARALLEL: [roles that can run together]\nCONTEXT: [files needed] or \"needs file_locator scan\"\nEXPECTED_OUTPUT: [what to produce]\nEVIDENCE_TYPE: QUOTE | LINE_REF | SCOPE_SCAN\nCOMPLEXITY: LOW | MEDIUM | HIGH\nESTIMATED_TIME: [e.g., 3-5 minutes]\nPRIORITY: LOW | NORMAL | HIGH\nFALLBACK: [reason if routing to chief]\n\nIf ambiguous, output: CLARIFY: [specific questions]\n\nIf dry_run=true, output a routing preview only (no final route)."
    },
    {
      "id": "canon_checker",
      "name": "Canon Checker",
      "archetype": "Continuity",
      "scope": "project",
      "usageNotes": "Use when verifying scene content against canon files.",
      "goals": "Ensure scenes do not contradict canon. Identify gaps explicitly.",
      "guardrails": "NEVER guess canon file paths. Always call Phase 1 (discovery, no canon_paths) first to get the manifest of available files. Only then call Phase 2 with exact paths from the manifest. Quote both canon and scene for any claim.",
      "prompt": "Tool call (JSON only; no extra text):\n\nIMPORTANT: Do NOT guess canon file paths. Always start with Phase 1 to discover available files.\n\nPhase 1 — DISCOVERY (always call this first, no canon_paths):\n{\"tool\":\"canon_checker\",\"args\":{\"scene_path\":\"Story/Scenes/SCN-scene-slug.md\",\"mode\":\"strict\"},\"nonce\":\"<TOOL_NONCE>\"}\nReturns: scene excerpt + manifest of all available canon files with path, name, category, and size.\nReview the manifest and select canon files relevant to the scene.\n\nPhase 2 — COMPARE (use exact paths from Phase 1 manifest):\n{\"tool\":\"canon_checker\",\"args\":{\"scene_path\":\"Story/Scenes/SCN-scene-slug.md\",\"canon_paths\":[\"Compendium/Characters/CHAR-name.md\"],\"mode\":\"strict\"},\"nonce\":\"<TOOL_NONCE>\"}\nReturns: scene content + canon file contents for comparison.\n\nArgs:\n- scene_path: string (required)\n- canon_paths?: string[] (omit for Phase 1 discovery; use exact paths from manifest for Phase 2)\n- mode?: string\n- dry_run?: boolean\n\nCanon files live under Compendium/ (not Story/Compendium/). Use discovery to get exact paths.\n\nVerify character, location, technology, culture, and historical facts.\nReport format:\nScene: [filename]\nCanon: [filename]\nScene quote: \"...\"\nCanon quote: \"...\"\nStatus: Consistent | Inconsistent | Canon gap\nRecommendation: [Add to canon / Revise scene / Flag for review]\n\nIf dry_run=true, output which files would be checked."
    },
    {
      "id": "outline_analyzer",
      "name": "Outline Analyzer",
      "archetype": "Planner",
      "scope": "project",
      "usageNotes": "Analyze story outline for structure, gaps, and stakes progression.",
      "goals": "Identify structural issues with grounded references to outline text.",
      "guardrails": "If outline path unknown, call file_locator first. Do not claim outline is missing without file_locator confirmation. Quote outline text for all structural claims.",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"outline_analyzer\",\"args\":{\"outline_path\":\"Story/SCN-outline.md\",\"mode\":\"structure\",\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- outline_path?: string\n- mode?: string\n- dry_run?: boolean\n\nIf outline_path not provided, call file_locator for \"outline\" and report results.\nIf no outline file exists, output: No outline file found.\n\nAnalyze:\n1) Scene count and distribution\n2) Stakes progression\n3) Act structure (setup/confrontation/resolution)\n4) Gaps or missing transitions\n5) POV balance\n\nReport format:\nStructure Overview: ...\nProblem Identified: [quote + location]\nSuggested Fix: [actionable change]\n\nIf dry_run=true, output which outline file would be analyzed."
    },
    {
      "id": "prose_analyzer",
      "name": "Prose Analyzer",
      "archetype": "Editor",
      "scope": "project",
      "usageNotes": "Use when examining a scene for prose quality, pacing, voice, sentence rhythm, or sensory detail. Returns computed metrics (sentence stats, dialogue ratio, repeated words, POV signals) plus file content for grounded analysis.",
      "goals": "Provide quantitative prose metrics so analysis is grounded in verifiable data, not subjective impressions.",
      "guardrails": "Quote specific passages for every claim. Cite metric values from the tool output. Never claim pacing is slow without referencing sentence length data. Distinguish between style preferences and structural problems.",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"prose_analyzer\",\"args\":{\"scene_path\":\"Story/Scenes/SCN-scene-slug.md\",\"focus\":\"all\",\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- scene_path: string (required) — VFS path to the scene file\n- focus?: \"pacing\" | \"voice\" | \"rhythm\" | \"all\" (default: \"all\")\n- dry_run?: boolean\n\nFocus modes:\n- pacing: sentence/paragraph counts, avg lengths, longest/shortest sentence\n- voice: POV pronoun signals, dialogue ratio\n- rhythm: sentence length variance, repeated words, adverb count\n- all: all of the above\n\nReturns computed metrics plus scene content excerpt.\n\nReport format:\nScene: [filename]\nPOV: [inferred from pov_signals]\n\nStrength Found:\nQuote: \"[exact text from scene]\"\nMetric: [relevant metric value]\nWhy it works: [specific reason]\n\nIssue Found (if any):\nQuote: \"[exact text from scene]\"\nMetric: [relevant metric value]\nProblem: [specific issue]\nLocation: [paragraph/sentence reference]\n\nSuggested Fix:\n[concrete rewrite suggestion or technique]\n\nIf dry_run=true, output which file would be analyzed."
    },
    {
      "id": "consistency_checker",
      "name": "Consistency Checker",
      "archetype": "Continuity",
      "scope": "project",
      "usageNotes": "Use when checking for contradictions across multiple scenes or files. Reads multiple files, extracts named entities and terminology, and builds cross-reference maps for grounded analysis.",
      "goals": "Find factual inconsistencies, terminology mismatches, and character behavior contradictions across files with verifiable evidence.",
      "guardrails": "MUST cite both conflicting passages with filenames. MUST distinguish between contradiction and character growth/change. NEVER flag stylistic variation as inconsistency. Quote from both files for every claim.",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"consistency_checker\",\"args\":{\"file_paths\":[\"Story/Scenes/SCN-slug.md\",\"Compendium/Characters/CHAR-name.md\"],\"focus\":\"general\",\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- file_paths: string[] (required) — VFS paths to compare (max 10)\n- focus?: \"characters\" | \"terminology\" | \"events\" | \"general\" (default: \"general\")\n- dry_run?: boolean\n\nFocus modes:\n- characters: entity cross-references, character name consistency\n- terminology: shared terms, naming drift across files\n- events: time markers, event ordering signals\n- general: all of the above\n\nReturns per-file entities, cross-reference map, shared terms, and content excerpts.\n\nReport format:\nConsistency Check: [files checked]\n\nIssue Found:\nFile 1: [filename] - \"[quote showing fact A]\"\nFile 2: [filename] - \"[quote showing contradictory fact B]\"\nType: Factual | Character | Terminology | Timeline\nSeverity: Major | Minor\n\nSuggested Resolution:\n[Which version to keep and why, or how to reconcile]\n\nNo Issues Found (if applicable):\n\"Checked [files] for [focus] - no contradictions found\"\n\nIf dry_run=true, output which files would be checked."
    },
    {
      "id": "scene_draft_validator",
      "name": "Scene Draft Validator",
      "archetype": "Any",
      "scope": "project",
      "usageNotes": "Use before finalizing a scene draft to check completeness. Auto-matches the scene to its outline beat and optionally loads the POV character's canon card. Returns all three pieces side-by-side for validation.",
      "goals": "Verify scene meets structural requirements, matches outline beat intent, and does not contradict canon. Bundle context that would otherwise require 3 tool calls.",
      "guardrails": "MUST check scene against outline beat if one exists. MUST verify POV character consistency with canon if include_canon is true. NEVER approve a scene that contradicts established facts. Quote scene, outline, and canon for any claim.",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"scene_draft_validator\",\"args\":{\"scene_path\":\"Story/Scenes/SCN-slug.md\",\"include_canon\":true,\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- scene_path: string (required) — VFS path to the scene file\n- outline_path?: string (default: \"Story/SCN-outline.md\")\n- include_canon?: boolean (default: true) — also load POV character's canon card\n- dry_run?: boolean\n\nReturns scene content, auto-matched outline beat (with match method), and optional POV canon card.\n\nValidation checklist:\n1. Does scene match outline beat intent?\n2. Is POV character voice consistent with canon?\n3. Does scene have clear beginning/middle/end?\n4. Are there contradictions with established canon?\n5. Are sensory details appropriate for species/setting?\n\nReport format:\nScene: [filename]\nOutline beat: [quote beat description or \"No match found\"]\n\nValidation Results:\nPASS: [aspect that passes with evidence]\nWARN: [aspect needing attention with quote]\nFAIL: [aspect that fails with quote from both scene and canon/outline]\n\nCanon Check:\nQuote from canon: \"[relevant canon text]\"\nScene text: \"[relevant scene text]\"\nStatus: Consistent | Inconsistent | Unclear\n\nRecommendation: APPROVE | REVISE | FLAG_FOR_REVIEW\n\nIf dry_run=true, output which files would be checked."
    },
    {
      "id": "issue_status_summarizer",
      "name": "Issue Status Summarizer",
      "archetype": "Chief",
      "scope": "project",
      "usageNotes": "Use when the user asks for project status, what is in progress, or a quick situational overview.",
      "goals": "Summarize open issues and show recent tool activity for the current session with receipt IDs (no guesswork).",
      "guardrails": "Do not invent issues or activity. If no receipts exist for the current session, say so.",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"issue_status_summarizer\",\"args\":{\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- dry_run?: boolean\n\nReturns:\n- active_issues (up to 20)\n- issue_counts\n- recent_activity (up to 5 receipts)\n- files_touched (derived from recent receipts)"
    },
    {
      "id": "stakes_mapper",
      "name": "Stakes Mapper",
      "archetype": "Planner",
      "scope": "project",
      "usageNotes": "Use to map external and internal stakes across an outline or across specific scene files.",
      "goals": "Provide grounded scene-by-scene context (outline summaries or scene excerpts) plus candidate stake lines to accelerate analysis.",
      "guardrails": "Do not assume outline path; use default Story/SCN-outline.md unless user specifies. If scenes are provided, use exact scene_paths.",
      "prompt": "Tool call (JSON only; no extra text):\n\nOutline-driven map:\n{\"tool\":\"stakes_mapper\",\"args\":{\"outline_path\":\"Story/SCN-outline.md\",\"max_scenes\":20,\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nScene-driven map:\n{\"tool\":\"stakes_mapper\",\"args\":{\"scene_paths\":[\"Story/Scenes/SCN-slug.md\"],\"max_scenes\":12,\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- outline_path?: string\n- scene_paths?: string[]\n- max_scenes?: number\n- dry_run?: boolean\n\nReturns:\n- scenes[] with summaries/excerpts and stakes_candidates[] (heuristic candidates for the model to interpret)"
    },
    {
      "id": "line_editor",
      "name": "Line Editor",
      "archetype": "Editor",
      "scope": "project",
      "usageNotes": "Use to surface line-level edit opportunities (clarity, repetition, filler, adverbs) for a passage or file excerpt.",
      "goals": "Produce deterministic, grounded edit findings so the model can propose safe rewrites without hallucinating source text.",
      "guardrails": "This tool does not rewrite prose; it flags edit opportunities. The model must preserve meaning and voice when proposing final revisions.",
      "prompt": "Tool call (JSON only; no extra text):\n\nFrom a file:\n{\"tool\":\"line_editor\",\"args\":{\"file_path\":\"Story/Scenes/SCN-slug.md\",\"start_line\":1,\"end_line\":120,\"max_edits\":12,\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nFrom inline text:\n{\"tool\":\"line_editor\",\"args\":{\"text\":\"...\",\"max_edits\":12,\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- file_path?: string\n- text?: string\n- start_line?: number\n- end_line?: number\n- max_edits?: number\n- dry_run?: boolean\n\nReturns:\n- excerpt + findings[] (each includes original snippet or signal and a suggestion)"
    },
    {
      "id": "scene_impact_analyzer",
      "name": "Scene Impact Analyzer",
      "archetype": "Critic",
      "scope": "project",
      "usageNotes": "Use to assess whether a scene has a strong hook, clear pressure, and a satisfying ending by loading opening/ending excerpts and basic impact signals.",
      "goals": "Bundle opening/ending excerpts, basic impact signals, and optional outline beat match in one call.",
      "guardrails": "Quote the scene text for all impact claims. If outline match is missing, do not assume intended purpose.",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"scene_impact_analyzer\",\"args\":{\"scene_path\":\"Story/Scenes/SCN-slug.md\",\"outline_path\":\"Story/SCN-outline.md\",\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- scene_path: string (required)\n- outline_path?: string (default: Story/SCN-outline.md)\n- dry_run?: boolean\n\nReturns:\n- opening, ending excerpts\n- impact_signals (dialogue ratio, punctuation, conflict-marker counts)\n- outline_match (best-effort)"
    },
    {
      "id": "reader_experience_simulator",
      "name": "Reader Experience Simulator",
      "archetype": "Critic",
      "scope": "project",
      "usageNotes": "Use to evaluate reading flow across a sequence of scenes by loading each scene's opening/ending and building transition pairs.",
      "goals": "Provide a grounded substrate so the model can simulate confusion/fatigue/engagement without inventing text.",
      "guardrails": "Use only the provided scene_paths in reading order. Quote the exact moments when describing reader friction.",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"reader_experience_simulator\",\"args\":{\"scene_paths\":[\"Story/Scenes/SCN-1.md\",\"Story/Scenes/SCN-2.md\"],\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- scene_paths: string[] (required, max 12)\n- dry_run?: boolean\n\nReturns:\n- scenes[] with opening/ending excerpts and entities\n- transitions[] with from_ending and to_opening excerpts"
    },
    {
      "id": "timeline_validator",
      "name": "Timeline Validator",
      "archetype": "Continuity",
      "scope": "project",
      "usageNotes": "Use to extract time markers from multiple files and build a quote-backed timeline skeleton for chronology checks.",
      "goals": "Extract time references (dates, 'three days later', morning/evening cues) with line numbers so contradictions can be flagged with evidence.",
      "guardrails": "Do not infer chronology beyond extracted quotes. Flashbacks are not errors by default; the model must interpret intent.",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"timeline_validator\",\"args\":{\"file_paths\":[\"Story/Scenes/SCN-1.md\",\"Story/Scenes/SCN-2.md\"],\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- file_paths: string[] (required, max 12)\n- dry_run?: boolean\n\nReturns:\n- per-file time_markers[] with line numbers\n- timeline[] flattened in reading order"
    },
    {
      "id": "beat_architect",
      "name": "Beat Architect",
      "archetype": "Any",
      "scope": "project",
      "usageNotes": "Use to turn a scene brief into a beat-cluster scaffold that downstream drafting can follow.",
      "goals": "Generate a cluster template (SCENE START → CONTINUATIONS → SCENE ENDING) and force clarification when the brief is underspecified.",
      "guardrails": "Never invent canon facts. If needs_clarification=true, ask the returned questions before generating beat content.",
      "prompt": "Tool call (JSON only; no extra text):\n{\"tool\":\"beat_architect\",\"args\":{\"scene_brief\":\"...\",\"density\":\"balanced\",\"max_clusters\":10,\"dry_run\":false},\"nonce\":\"<TOOL_NONCE>\"}\n\nArgs:\n- scene_brief: string (required)\n- density?: \"lean\" | \"balanced\" | \"dense\"\n- max_clusters?: number\n- dry_run?: boolean\n\nReturns:\n- confidence_in_comprehension + needs_clarification\n- questions[] (if clarification needed)\n- cluster_templates[] scaffold (if ready)\n\nThe model should fill each cluster with concrete, canon-aware content."
    }
  ]
}
